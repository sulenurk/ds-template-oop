# -*- coding: utf-8 -*-
"""eda_utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RgyRp1e7qFq6Uv13H9Eptj3_68aOXEvk
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler

# Function to split feature and target columns and optionally normalize numeric features
def split_feature_cols(df, id_cols, target_col=None, normalize=False):
    """
    Split the DataFrame into features and target, also separating numeric and categorical features.

    Parameters:
    - df: Input DataFrame
    - id_cols: Number of ID columns to drop from the left
    - target_col: Name of the target column (defaults to last column if None)
    - normalize: If True, numeric features will be normalized using MinMaxScaler

    Returns:
    - feature_df: DataFrame with only feature columns (normalized if requested)
    - features_target_df: DataFrame with features + target (for reference)
    - num_cols: List of numeric column names
    - cat_cols: List of categorical column names
    - feature_cols: List of all feature column names
    """
    features_target_df = df.iloc[:, id_cols:]
    if target_col is None:
        target_col = df.columns[-1]
    feature_df = features_target_df.drop(columns=[target_col])
    num_cols = feature_df.select_dtypes(include=['float64', 'int64']).columns
    cat_cols = feature_df.select_dtypes(include=['object']).columns
    feature_cols = feature_df.columns

    if normalize:
        scaler = MinMaxScaler()
        feature_df[num_cols] = scaler.fit_transform(feature_df[num_cols])

    return feature_df, features_target_df, num_cols, cat_cols, feature_cols

# Draw histograms for numeric columns with optional grouping and density option
def draw_histograms(dataframe, feature_columns, hue=None, bins=50, dimension=(6, 4), density=False):
    """
    Plot histograms for one or more numeric features.

    Parameters
    ----------
    dataframe : pd.DataFrame
        Source data.
    feature_columns : list[str]
        Numeric column names to be visualized.
    hue : str, optional
        Categorical column used to color and split the histogram bars.
    bins : int, default=50
        Number of histogram bins.
    dimension : tuple[int, int], default=(6, 4)
        Figure size in inches *(width, height)*.
    density : bool, default=False
        If ``True``, the histogram is normalized to show probability density;
        otherwise, raw counts are displayed.

    Returns
    -------
    None
        Displays one histogram per feature column.
    """
    for col in feature_columns:
        plt.figure(figsize=dimension)
        if hue:
            sns.histplot(data=dataframe, x=col, hue=hue, bins=bins, kde=False,
                         palette='viridis', edgecolor='#D3D3D3', stat='density' if density else 'count')
        else:
            plt.hist(dataframe[col], bins=bins, color='#4682B4', edgecolor='#D3D3D3', density=density)

        plt.title(f'Histogram of {col}' + (f' by {hue}' if hue else ''))
        plt.xlabel(col)
        plt.ylabel('Density' if density else 'Frequency')
        plt.grid(True, linestyle='--', alpha=0.8)
        plt.show()

# Draw boxplots for numeric columns
def draw_boxplots(dataframe, numeric_cols):
    """
    Plot a separate boxplot for each numeric feature.

    Parameters
    ----------
    dataframe : pd.DataFrame
        Source data.
    numeric_cols : list[str]
        Column names to be plotted.

    Returns
    -------
    None
        Displays a boxplot for every column in *numeric_cols*.
    """

    color = '#1f4591'
    for col in numeric_cols:
        plt.figure(figsize=(4, 4))
        sns.boxplot(data=dataframe[col], color=color, flierprops={'marker': 'o', 'markersize': 3})
        plt.title(f"Boxplot of {col}")
        plt.grid(True, linestyle="--", linewidth=0.5, alpha=0.7)
        plt.show()

# Draw a pairplot for numeric columns colored by target
def draw_pairplot(df, target_col):
    """
    Generate a Seaborn *pairplot* for all numeric features.

    Parameters
    ----------
    df : pd.DataFrame
        Dataset containing numeric features and a target column.
    target_col : str
        Column used for hue-coloring the scatter-matrix.

    Returns
    -------
    None
        Displays the pairplot.
    """

    sns.pairplot(df, hue=target_col)
    plt.show()

# Draw a correlation heatmap for numeric features
def draw_heatmap(df):
    """
    Plot a correlation heatmap of numeric features.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame with numeric columns.

    Returns
    -------
    None
        Displays an annotated heatmap of Pearson correlations.
    """

    plt.figure(figsize=(10, 8))
    sns.heatmap(df.corr(), annot=True, cmap='crest')
    plt.title("Correlation Heatmap")
    plt.show()

# Plot bar charts for all categorical features with optional normalization and hue
def plot_all_barcharts(data, hue=None, normalize=False, dimension=(10, 6)):
    """
    Draw bar charts for every categorical feature in *data*.

    Parameters
    ----------
    data : pd.DataFrame
        Source data containing categorical columns.
    hue : str, optional
        Second categorical column for stacked/side-by-side bars.
    normalize : bool, default=False
        If ``True``, bars represent proportions; otherwise, raw counts.
    dimension : tuple[int, int], default=(10, 6)
        Figure size in inches *(width, height)*.

    Returns
    -------
    None
        Displays one bar chart per categorical feature.
    """
    for column in data.columns:
        if pd.api.types.is_numeric_dtype(data[column]):
            continue

        plt.figure(figsize=dimension)

        if normalize:
            if hue:
                grouped_data = data.groupby([column, hue]).size().unstack()
                grouped_data = grouped_data.div(grouped_data.sum(axis=1), axis=0)
                grouped_data.plot(kind='bar', stacked=True, figsize=dimension)
                plt.ylabel('Normalized Count')
            else:
                counts = data[column].value_counts(normalize=True)
                sns.barplot(x=counts.index, y=counts.values, order=counts.index)
                plt.ylabel('Normalized Count')
        else:
            sns.countplot(x=data[column], hue=hue, data=data)
            plt.ylabel('Count')

        plt.title(f'Bar Chart of {column}' + (f' by {hue}' if hue else ''))
        plt.xlabel(column)
        plt.xticks(rotation=45)
        plt.show()

# Plot heatmaps for categorical feature combinations with optional normalization
def plot_categorical_heatmaps(df, col1=None, col2=None, normalization=None):
    """
    Plot heatmaps for all (or specified) pairs of categorical features.

    Parameters
    ----------
    df : pd.DataFrame
        Dataset containing categorical columns.
    col1, col2 : str, optional
        If both are provided, only their cross-tabulation is plotted.
        Otherwise, heatmaps for every unique column pair are generated.
    normalization : {'row', 'column', None}, default=None
        • ``'row'``    → each row is normalized to sum to 1  
        • ``'column'`` → each column is normalized to sum to 1  
        • ``None``     → raw counts are shown.

    Returns
    -------
    None
        Displays one heatmap per selected category pair.
    """
    cat_columns = df.select_dtypes(include=['object', 'category']).columns
    pairs = [(col1, col2)] if col1 and col2 else [(c1, c2) for i, c1 in enumerate(cat_columns) for c2 in cat_columns[i+1:]]

    for col1, col2 in pairs:
        cross_tab = pd.crosstab(df[col1], df[col2])

        if normalization == "row":
            cross_tab = cross_tab.div(cross_tab.sum(axis=1), axis=0)
        elif normalization == "column":
            cross_tab = cross_tab.div(cross_tab.sum(axis=0), axis=1)

        plt.figure(figsize=(8, 6))
        sns.heatmap(cross_tab, annot=True, cmap="coolwarm", fmt=".2f" if normalization else "d")
        plt.title(f"Heatmap of {col1} vs {col2} ({'No Normalization' if normalization is None else normalization.capitalize() + ' Normalization'})")
        plt.xlabel(col2)
        plt.ylabel(col1)
        plt.show()

# Analyze each categorical feature against the target with stacked histograms and counts
def plot_categorical_analysis(df, target_col):
    """
    Analyse each categorical feature against the target distribution.

    For every categorical column (excluding *target_col*), the function:
    1. Plots a stacked histogram (% share per target class).  
    2. Prints the value counts per target class.

    Parameters
    ----------
    df : pd.DataFrame
        Source data.
    target_col : str
        Classification target column.

    Returns
    -------
    None
        Displays plots and prints counts to stdout.
    """
    categorical_columns = df.select_dtypes(include=['object', 'category']).columns
    categorical_columns = [col for col in categorical_columns if col != target_col]

    for col in categorical_columns:
        print(f"Analyzing column: {col}")

        plt.figure(figsize=(10, 6))
        sns.histplot(data=df, x=col, hue=target_col, multiple='stack', palette='viridis', stat='percent')
        plt.title(f'Distribution of {col} by {target_col}')
        plt.xticks(rotation=45)
        plt.show()

        value_counts = df.groupby(target_col)[col].value_counts()
        print(f"Value counts for {col} by {target_col}:")
        print(value_counts, "\n")

def plot_categorical_distributions(df, target_col, normalize=False, figsize=(15, 10)):
    """
    Plot side-by-side or percentage bar charts for all categorical features.

    Parameters
    ----------
    df : pd.DataFrame
        Dataset containing categorical columns and the target column.
    target_col : str
        Column used for hue-splitting the bars.
    normalize : bool, default=False
        If ``True``, bars show class-wise percentages; otherwise, raw counts.
    figsize : tuple[int, int], default=(15, 10)
        Overall figure size for the subplot grid.

    Returns
    -------
    None
        Displays a grid of bar charts; non-existent axes are hidden.
    """
    categorical_cols = df.select_dtypes(include=['object', 'category']).columns.tolist()

    if target_col in categorical_cols:
        categorical_cols.remove(target_col)

    if not categorical_cols:
        print("No categorical cols!")
        return
    
    n_cols = 2
    n_rows = int(np.ceil(len(categorical_cols) / n_cols))
    fig, axes = plt.subplots(n_rows, n_cols, figsize=figsize)
    axes = axes.flatten()

    for i, col in enumerate(categorical_cols):
        ax = axes[i]

        if normalize:
            prop_df = (df.groupby(col)[target_col]
                        .value_counts(normalize=True)
                        .mul(100)
                        .rename('percentage')
                        .reset_index())

            sns.barplot(x=col, y='percentage', hue=target_col, data=prop_df, ax=ax)
            ax.set_ylabel('Percentage (%)')
            ax.set_title(f'{col} Distribution by {target_col} (%)')
        else:
            sns.countplot(x=col, hue=target_col, data=df, ax=ax)
            ax.set_ylabel('Count')
            ax.set_title(f'{col} Distribution by {target_col} (Count)')

        ax.tick_params(axis='x', rotation=45)

        ax.legend(title=target_col, bbox_to_anchor=(1.05, 1), loc='upper left')

    for j in range(i+1, len(axes)):
        axes[j].set_visible(False)

    plt.tight_layout()
    plt.show()