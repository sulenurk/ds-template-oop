# -*- coding: utf-8 -*-
"""shap_py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xcA3TBGmEvS8fWlkycnLlVgI6quP-bdb
"""

import shap
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import os

def shap_values(model_info, df):
  """
    Compute SHAP values for all observations in *df*.

    Parameters
    ----------
    model_info : dict
        Dictionary whose key ``'model'`` maps to a fitted estimator compatible
        with `shap.Explainer`.
    df : pd.DataFrame
        Feature matrix (no target column).

    Returns
    -------
    pd.DataFrame
        SHAP value matrix with the same column order as *df*.

    Notes
    -----
    - A model-agnostic `shap.Explainer` is instantiated internally.
    - For heavy tree models consider passing a specialised explainer to speed up
      computation.
    """

  model = model_info['model']

  # Choose appropriate SHAP explainer
  explainer = shap.Explainer(model, feature_names=df.columns)

  shap_values = explainer(df)

  shap_values_df = pd.DataFrame(shap_values.values, columns=df.columns)

  # Compute SHAP values
  return shap_values_df

#helper functions
def _encode_categoricals(df):
    """
    Label-encode all object/category columns.

    Parameters
    ----------
    df : pd.DataFrame
        Original feature matrix.

    Returns
    -------
    pd.DataFrame
        Copy of *df* where categorical columns are replaced by integer codes.

    Notes
    -----
    - Non-categorical columns are left unchanged.
    - Intended for internal use prior to SHAP plotting.
    """
    df_enc = df.copy()
    for col in df_enc.select_dtypes(include=["object", "category"]).columns:
        df_enc[col], _ = pd.factorize(df_enc[col])
    return df_enc

def _to_numpy_shap(vals):
    """
    Convert SHAP values to NumPy format for plotting.

    Parameters
    ----------
    vals : pd.DataFrame | np.ndarray | list
        SHAP output (single array/DataFrame or list per class).

    Returns
    -------
    np.ndarray | list[np.ndarray]
        NumPy array (or list of arrays) ready for `shap.summary_plot`.
    """
    if isinstance(vals, pd.DataFrame):
        return vals.values
    if isinstance(vals, list):
        return [_to_numpy_shap(v) for v in vals]
    return vals


def global_analysis(
        shap_values,
        df,                      # df[features]
        top_n_features=10,
        save_path=None,
        encode_categoricals=True,
    ):
    """
    Generate global SHAP visualisations: bar, dot and (for small data) heatmap.

    Parameters
    ----------
    shap_values : pd.DataFrame | np.ndarray | list
        SHAP values computed for *df*.
    df : pd.DataFrame
        Feature matrix (train+test merge). Target column must be absent.
    top_n_features : int, default=10
        Maximum number of features to display in summary plots.
    save_path : str, optional
        Directory path for saving PNG images. If ``None``, figures are
        displayed but not saved.
    encode_categoricals : bool, default=True
        If ``True``, categorical columns are label-encoded for dot plots.

    Returns
    -------
    None
        Displays and optionally saves SHAP bar, dot, and heatmap plots.

    Notes
    -----
    - Heatmap is attempted only when the dataset has â‰¤100 rows.
    - Any exceptions during plotting are caught and printed, preventing the
      analysis pipeline from crashing.
    """
    df_plot = _encode_categoricals(df) if encode_categoricals else df
    X_np = df_plot.values
    feature_names = df_plot.columns.tolist()
    shap_np = _to_numpy_shap(shap_values) 

    # --- Bar Summary -------------------------------------------------------- #
    shap.summary_plot(
        shap_np,
        features=X_np,
        feature_names=feature_names,
        plot_type="bar",
        max_display=top_n_features,
        show=False,
    )
    plt.title("Feature Importance (SHAP)")
    if save_path:
        plt.savefig(f"{save_path}/shap_summary_bar.png",
                    bbox_inches="tight", dpi=300)
    plt.show()

    # --- Dot Summary -------------------------------------------------------- #
    shap.summary_plot(
        shap_np,
        features=X_np,
        feature_names=feature_names,
        max_display=top_n_features,
        show=False,
    )
    plt.title("SHAP Value Distribution")
    if save_path:
        plt.savefig(f"{save_path}/shap_summary_dot.png",
                    bbox_inches="tight", dpi=300)
    plt.show()

    # Plot: SHAP Heatmap (for small datasets only)
    try:
        if df.shape[0] <= 100:  # avoid overload on large data
            shap.plots.heatmap(shap_values, show=False)
            plt.title("SHAP Heatmap")
            if save_path:
                plt.savefig(f"{save_path}/shap_heatmap.png", bbox_inches='tight', dpi=300)
            plt.show()
    except Exception as e:
        print(f"Heatmap plot could not be generated: {e}")

def index_charts(shap_values, sample_index, top_n_features=10, save_path=None):
  """
    Plot per-instance waterfall and decision charts.

    Parameters
    ----------
    shap_values : shap.Explanation | list
        SHAP explanation object returned by the explainer.
    sample_index : int
        Row index of the observation to visualise.
    top_n_features : int, default=10
        Maximum number of features in the waterfall plot.
    save_path : str, optional
        Directory path for saving PNG images. If ``None``, figures are not saved.

    Returns
    -------
    None
        Displays (and optionally saves) the waterfall and decision plots.
    """
  shap.plots.waterfall(shap_values[sample_index], max_display=top_n_features, show=False)
  plt.title(f"Waterfall Plot - Sample {sample_index}")
  if save_path:
      plt.savefig(f"{save_path}/waterfall_sample_{sample_index}.png", bbox_inches='tight', dpi=300)
  plt.show()

  # Plot 4: SHAP Decision Plot
  try:
      shap.plots.decision(shap_values[sample_index], show=False)
      plt.title(f"Decision Plot - Sample {sample_index}")
      if save_path:
          plt.savefig(f"{save_path}/decision_plot_sample_{sample_index}.png", bbox_inches='tight', dpi=300)
      plt.show()
  except Exception as e:
      print(f"Decision plot could not be generated: {e}")

def index_feature(shap_values, df, save_path=None):
  """
    Plot a dependence scatter for the single most impactful feature.

    Parameters
    ----------
    shap_values : shap.Explanation
        SHAP explanation object for the dataset *df*.
    df : pd.DataFrame
        Feature matrix corresponding to *shap_values*.
    save_path : str, optional
        Directory path where the plot will be saved. Created if absent.

    Returns
    -------
    None
        Displays (and optionally saves) the dependence plot.

    Notes
    -----
    - The top feature is selected by mean absolute SHAP value.
    - Errors encountered during plotting are caught and logged.
    """

  # Create directory if save_path is given
  if save_path:
    os.makedirs(save_path, exist_ok=True)

  # Dependence Plot for Top Feature
  try:
      shap_values_abs = np.abs(shap_values.values).mean(axis=0)
      top_feature_idx = np.argsort(shap_values_abs)[-1]
      top_feature_name = df.columns[top_feature_idx]
      shap.plots.scatter(shap_values[:, top_feature_idx], show=False)
      plt.title(f"Dependence Plot - {top_feature_name}")
      if save_path:
          plt.savefig(f"{save_path}/dependence_plot_{top_feature_name}.png", bbox_inches='tight', dpi=300)
      plt.show()
  except Exception as e:
      print(f"Dependence plot could not be generated: {e}")